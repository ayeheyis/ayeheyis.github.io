<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Parallelizing Heat Method</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Parallelizing the Heat Method</h1>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h3 class="octicon octicon-link">Summary</h3>
            <p> 
              We are going to parallelize the computation of geodesic distance between points using the heat method, expanding upon a sequential solution. The focus will be on parallelizing the method for solving linear equations and the computations made to normalize the gradient. To accomplish this, we will use a lab machine with a quality GPU and CPU such as ghc41 or latedays.
            </p>
          <h3 class="octicon octicon-link">Background</h3>
            <p>
              The heat method is a new procedure for approximating the geodesic distance of two points, which is the shortest line that connects two points along a curved surface area. The heat method has shown to be simple, easy to implement, accurate, and most importantly it can be applied to virtually any geometric discretization such as grids and meshas. 
              <br> <br>
              The simplicity of the method comes from the fact that it only requires a solution to two standard linear elliptic problems. Thus, to improve on the current implementation, we need to (I) construct the appropriate matrix for the different systems in parallel. (II) We need to implement a sparse linear solver. Note that the sparse linear solver must be able to deal with symmetric positive-definite systems.
            </p>

            <img src="images/outline.PNG" alt="Outline">
          <h3 class="octicon octicon-link">The Challenge</h3>

          <h3 class="octicon octicon-link">Resources</h3>
            We intend to build off of the current starter code which is completely sequential. The starter code is in C and we will continue to use C throughout the project. We plan on using OpenMP and Cuda to make the program parallel. 
            <br> <br>
            To gain more understanding in the domain, we plan on using a paper written by Keenan Crane. The paper essentially describes what the heat method is and how it can be implemented. A link to the paper is in the reference section. 
          <h3 class="octicon octicon-link">Platform Choice</h3>
            <br>
            <p> <b>Planned Goals</b> </p>
            <ol>
              <li> 
                An OpenMP and Cuda 
              </li>
            </ol>
          <h3 class="octicon octicon-link">Schedule</h3>
        </section>
      </div>
    </div>
  </body>
</html>